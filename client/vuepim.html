<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"> 
<meta name="viewport" content="width=device-width, initial-scale=1">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

<script src="https://unpkg.com/vue"></script>
<script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue-strap/1.1.29/vue-strap.min.js"></script>

<script src="pim-ajax.js"></script>

</head>

<body>
<nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="#">PIM</a>
    </div>
    <ul class="nav navbar-nav">
      <li class="active"><a href="#">Today</a></li>
      <li><a href="#">Planning</a></li> 
      <li><a href="#">Mission</a></li> 
    </ul>
    <ul class="nav navbar-nav navbar-right">
      <li><a href="#"><span class="glyphicon glyphicon-user"></span> Sign Up</a></li>
      <li><a href="#"><span class="glyphicon glyphicon-log-in"></span> Login</a></li>
    </ul>
  </div>
</nav>

<div id="pim-root" class="container-fluid">

<h1 class="text-center bg-primary lead">
	TODAY: Work on PIM UI
	<button type="button" class="btn btn-xs btn-primary" data-toggle="modal" data-target="#myModal">
  		<span class="glyphicon glyphicon-plus"></span>&nbsp;
	</button>
</h1>

<div class="row">

  <div class="col-sm-4">
    <pim-task-list :task-list="scheduled" title="Calendar" v-on:toggle="adjustTask" />
  </div>


  <div class="col-sm-4">
    <pim-task-list :task-list="stuff" title="Stuff To Do" v-on:toggle="adjustTask" />
  </div>


  <div class="col-sm-4">
    <pim-task-list :task-list="done" title="Done" v-on:toggle="adjustTask" />
  </div>
</div>

</div>

<!-- Modal -->
<div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
        <h4 class="modal-title" id="myModalLabel">Create New Task</h4>
      </div>
      <form id="newTask" action="createTask">
        <div class="modal-body">
          <div class="form-group">
            <label for="task">Task:</label>
            <input type="text" class="form-control" id="task" aria-describedby="taskHelp" placeholder="Enter task name">
            <small id="taskHelp" class="form-text text-muted">Short summary name for your task.</small>
          </div>
          <div class="form-group">
            <label for="startdate">Start Date:</label>
            <input type="date" class="form-control" id="startdate">
          </div>
          <div class="form-group">
            <label for="starttime">Start Time:</label>
            <input type="time" class="form-control" id="starttime">
          </div>
          <div class="form-group">
            <label for="durartion">Estimate (minutes):</label>
            <input type="number" class="form-control" id="duration">
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-warning" data-dismiss="modal" onclick="deleteTask()" id="delete">Delete Task</button>
          <button type="button" class="btn btn-secondary" data-dismiss="modal" id="cancel">Cancel</button>
          <button type="button" class="btn btn-primary" data-dismiss="modal" onclick="upsertTask()" id="save">Save Task</button>
        </div>
      </form>
    </div>
  </div>
</div>


<script>

var nSecPerMinute = 60000000000;


// create our basic task view model
class Task {
  constructor(id, name, startTime, estimate, complete) {
    this.id = id;               // id of the task on the server
    this.name = name;           // name of the task
    this.startTime = startTime; // start time or date
    this.estimate = estimate;   // in minutes
    this.complete = complete;   // true if the task is done - OBSOLETE
  }

  isComplete() {
    return (this.state == Task.states.COMPLETE);
  }

  // return the esimtate as a number even if null
  getEstimate() {
    return (isNaN(this.estimate) ? 0 : this.estimate);
  }

  // return true if we have a start time on this task
  hasStartTime() {
    return (this.startTime != null); // should check type?  typescript?
  }

  // utility function to convert minutes to a more
  // concise format if over an hour or not provided
  // at all.
  static formatMinutes(minutes) {
    if (minutes == null) {
      return "";
    }
    else if (minutes <= 60) {
      return minutes;
    }
    else {
      var hours = Math.floor(minutes / 60);
      var minleft = minutes - (hours * 60);
      return hours + ":" + (minleft<=9?"0":"") + minleft;
    }
  }

  // utility function to format a time from a date object
  static formatTime(date) {
    if (date == null) {
      return "";
    }
    var hr = date.getHours();
    var min = date.getMinutes();
    if (min < 10) {
      min = "0" + min;
    }
    var ampm = null;
    if (hr < 12) {
    	ampm = 'am';
    } else {
    	ampm = 'pm';
    	if (hr >= 13) {
    		hr -= 12
    	}
    }
    return hr + ":" + min + ampm;
  }

  // return the estimated minutes in readable format
  estimateString() {
    return Task.formatMinutes(this.estimate);
  }

  // return start time as formated string of just the time
  startTimeString() {
    if (this.startTime == null) {
      return "";
    }
    else {
      return Task.formatTime(this.startTime) + ' - ';
    }
  }

} // class Task


// class list holds a list of tasks
class TaskList {
  constructor() {
    this.tasks = [];
    this.title = "";
    this.id = "";
  }

  title() {
  	return this.title;
  }

  setTitle(newTitle) {
  	this.title = newTitle;
  }

  getId() {
  	return id;
  }

  setId(newId) {
  	this.id = newId;
  }

  // add a task and keep in time order unless requested not to
  insertTask(task, placement = 'end') {

    // interpret placement as either:
    //   - instruction to place at 'end'
    //   - instruction to place in time order
    //   - insutrction to place after task with that 'id'
    var bTimeSort = (placement == 'timesort')
    var bInsertAfter = (!bTimeSort && placement != 'end')

	  // don't allow the same task 2x in this list
  	if (this.findTask(task.id) != null) {
  		return; 
  	}

  	// if no time sort needed add to the end
    if ((!task.hasStartTime() || !bTimeSort) && (!bInsertAfter)) {
      this.tasks.push(task);
    }

    // if time sort needed run the list to insert
    else if (bTimeSort) {
      var list = this.tasks;
      var i = 0;
      while (i < list.length && task.startTime > list[i].startTime) {
        i++;
      }

      // if i'm off the end then add to the end otherwise insert
      if (i >= list.length) {
        list.push(task);
      } else {
        list.splice(i, 0, task);
      }    
    }
    // if time sort needed run the list to insert
    else if (bInsertAfter) {
      var list = this.tasks;
      var i = 0;
      while (i < list.length && placement != list[i].id) {
        i++;
      }

      // if i'm off the end then add to the end otherwise insert
      if (i >= list.length) {
        list.push(task);
      } else {
        list.splice(i, 0, task);
      }    
    }
  }

  // remove a task from the list
  removeTask(task) {
    var i = this.tasks.indexOf(task);
    if (i >= 0) {
      this.tasks.splice(i,1);
    }
  }

  // find a task by id
  findTask(id) {
    var len = this.tasks.length;
    var result = null;
  	for (var i = 0; i < len && result == null; i++) {
  		if (this.tasks[i].id == id) {
  			result = this.tasks[i];
  		}
  	}
  	return result;
  }

  // recompute the estimated duraction of the entire list
  duration() {
    if (this.tasks == null || this.tasks.length == 0) {
      return 0;
    }
    var total = 0;
    var len = this.tasks.length;
    for (var i = 0; i < len; i++) {
      total += this.tasks[i].getEstimate();
    }
    return total;    
  }

  // format the duration as hours and minutes hh:mm
  durationFormatted() {
    var minutes = this.duration();
    return Task.formatMinutes(minutes);
  }  

  numTasks() {
    return this.tasks.length;
  }

}

function guid() {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
      .toString(16)
      .substring(1);
  }
  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
    s4() + '-' + s4() + s4() + s4();
}

function upsertTask() {
	var t = null;
	var f = document.getElementById("newTask");
	var name = f.elements["task"].value;
  var strdate = f.elements["startdate"].value;
	var strtime = f.elements["starttime"].value;
	var time = null;
	if ((strtime.length > 0) && (strdate.length > 0)) {
	  	time = new Date(strdate + " " + strtime);
	}
	var duration = parseInt(f.elements["duration"].value);
	if (isNaN(duration)) {
		duration = null;
	}
	if (currTask == null) {
		t = new Task(null, name, time, duration, false);
    writeTask(t, "POST"); // create a new task on the server
		var list = stuff;
		var sort = false;
		if (time != null) {
			list = scheduled;
			sort = true;
		}
 		list.insertTask(t, sort?'timesort':'end');
	} else {
		t = currTask;
		t.name = name;
		t.startTime = time; // TBD: not working?
		t.estimate = duration;
		moveTask(t);
		currTask = null;
    writeTask(t,"PUT"); // update the task that changed
	}
}

function deleteTask() {
	if (currTask == null) {
		return;
	}

	// remove task from any list it is in
	done.removeTask(currTask);
	stuff.removeTask(currTask);
	scheduled.removeTask(currTask);

  // delete the task from the server (when we write it)
  // killTask(currTask);

	// remove what we hope is the last reference to the task
	currTask = null;
}


// search all the lists for the task
function findTask(id) {
	found = null;
	found = scheduled.findTask(id);
	if (!found) {
		found = stuff.findTask(id);
	}
	if (!found) {
		found = done.findTask(id);
	}
	return found;
}

// create a component with the property "task" which is expected to be an object with
// attributes for whether it is "complete", some "text" and an "id".  The task is
// displayed as a checkbox bound to the "complete" field of the task object provided


Vue.component('pim-start-time', {
  props: ['task'],
  template: '<span v-if="task.hasStartTime()"><strong><small>{{task.startTimeString()}}</small></strong></span>'
})

Vue.component('pim-task-name', {
	props: ['name', 'id'],
	template: '<a href="#myModal" \
				  data-toggle="modal" \
	              data-target="#myModal" \
	              :data-taskid="id">{{name}}</a>',
})

Vue.component('pim-task-estimate', {
	props: ['estimate'],
	template: '<span class="badge">{{estimate}}</span>' 
})

Vue.component('pim-task', {
  props: ['task'],
  methods: {
    toggle: function() {
      this.$emit('toggle', this.task);
    }
  },
  template:'<div :id="task.id" class="checkbox" draggable="true" ondragstart="drag(event)" \
                 ondrop="drop(event)" ondragover="allowDrop(event)"> \
              <label> \
                <input type="checkbox" :id="task.id" v-model="task.complete" \
                	   v-on:click="toggle"> \
              	<pim-start-time :task="task"></pim-start-time> \
              	<pim-task-name :name="task.name" :id="task.id"></pim-task-name> \
              </label> \
              <pim-task-estimate :estimate="task.estimateString()"></pim-task-estimate> \
            </div>'
})

Vue.component('pim-add', {
	props: ['id'],
	template: '<a href="#myModal" \
	              data-toggle="modal" \
	              data-target="#myModal" \
	              :data-list="id"> + </a>'
})


Vue.component('pim-task-list', {
  props: ['taskList', 'title', 'add'],
  data: function () {
    return {
      numTasks: this.taskList.tasks.length,
      id: this.taskList.id,
    }
  },
  methods: {
    toggle: function(task) {
      this.$emit('toggle', task);
    },

    newtask: function (event) {
      alert('Hello ' + this.title + '!')
      // `event` is the native DOM event
      alert(event.target.tagName)
    },
  },
  template: '<div class="panel panel-primary"> \
               <div class="panel-heading"> \
                <h4 class="panel-title">{{title}} \
                <pim-add v-if="this.add" :id="id" /> \
                <span v-if="this.taskList.duration()" class="badge pull-right" >{{this.taskList.durationFormatted()}}</span></h4> \
               </div> \
               <div class="list-group">\
                <template v-for="task in taskList.tasks">\
                 <pim-task :task="task" class=list-group-item v-on:toggle="toggle" /> \
               </template> \
              </div> \
            </div>'
})

function allowDrop(ev) {
    ev.preventDefault();
}

function drag(ev) {
    ev.dataTransfer.setData("id", ev.target.id);
}

function drop(ev) {
    ev.preventDefault();
    var id = ev.dataTransfer.getData("id");
    dragDropTask(id, ev.target.id)
}

// for now we have no way to drop something to the end of a list
function dragDropTask(idDropped, idOn) {
  // check stuff and done for the task (calendar reorder by setting time)
  var list = null;
  var dropped = stuff.findTask(idDropped)
  if (dropped != null) {
    list = stuff
  }
  if (list == null) {
    dropped = done.findTask(idDropped)
    if (dropped != null) {
      list = done
    }
  }
  // you can only drop yourself within the same list
  if (dropped != null && list.findTask(idOn)) {
    list.removeTask(dropped)
    list.insertTask(dropped, idOn)
  }
}

function extractTimeString(timestamp) {
	if (timestamp == null) {
		return null;
	}
	var hr = timestamp.getHours();
	var mn = timestamp.getMinutes();
	var hrstr = (hr < 10 ? "0" + hr : hr);
	var mnstr = (mn < 10 ? "0" + mn : mn);
	return hrstr + ":" + mnstr + ":" + '00';
}

function extractDateString(timestamp) {
  parts = timestamp.toISOString().split("T");
  strDate = parts[0];
  return strDate;  
}

function stringToDate(strDate) {
  console.log(strDate);
  console.log(Date.parse(strDate.substring(0,strDate.length-1)));
  return new Date(strDate.substring(0,strDate.length-1));
}

// handle the DISPLAY of the New/Edit Modal Dialog
// we did all this list to track which list to ad to, then realized
// we'd prefer to use whether or not the user entered a time to
// decide which list to put the new task into.  oh well.
var currList = null;
var currTask = null; // remember it so we don't have to look it up again on submit
$('#myModal').on('show.bs.modal', function (event) {

	// find any data the invocation is trying to send us
  	var button = $(event.relatedTarget) // Button that triggered the modal
  	currList = taskListFromID(button.data('list')) // Extract info from data-* attributes
  	currTask = findTask(button.data('taskid'))

  	// initialize or clear the modal's form fields
  	var title = null;
  	var f = document.getElementById("newTask");
  	if (currTask != null) {
  		title = "Edit Task: " + currTask.name
  		f.elements["task"].value = currTask.name;
      f.elements["startdate"].value = extractDateString(currTask.startTime);
  		f.elements["starttime"].value = extractTimeString(currTask.startTime);
  		f.elements["duration"].value = currTask.estimate;  	
  		f.elements["delete"].style.visibility = 'visible';

  	} else {
  		title = "Create New Task";
  		f.elements["task"].value = null;
  		f.elements["startdate"].value = new Date().toISOString().split('T')[0];
      f.elements["starttime"].value = null;
  		f.elements["duration"].value = null;
  		f.elements["delete"].style.visibility = 'hidden';  	
  	}
  	
	// now initialize the box with that information
  	var modal = $(this)
  	modal.find('.modal-title').text(title)
})

// the ajax calls will initially load tasks into these lists
// depending on the attributes on the tasks
var scheduled = new TaskList();
var stuff = new TaskList();
var done = new TaskList();

// call the server to create a new task
function writeTask(task, directive) {

  // collect the task from the form elements
  var id = "";
  if (directive == "POST") {
    if (task.id != null || task.id == "") {
      console.log("error: id should be null on create.  aborting create.");
      return;
    }
  }
  else {
    if (task.id == null || task.id.length == 0) {
      console.log("error: id must be specified on update.  aborting update.");
      return;
    }
    id = task.id;
  }

  ajax = ajaxObj();

  ajax.onreadystatechange = function() {
    if (this.readyState == 4) {
      if (this.status == 200) {
        console.log("success: task created or updated")
        serverTask = JSON.parse(this.responseText);
        task.id = serverTask.id;
      }
    }
  };
  // a little confusing but it saves a lot of code
  // wrapper task passes in the right directive and based
  // on the directive (POST, PUT, PATCH) we've set up
  // the id to be valid or not to build the right URL
  ajaxPayload(ajax, tasksURL(id), task, directive);
}


// call the server to get our initial list of tasks
function loadTasks() {
  ajax = ajaxObj();
  ajax.onreadystatechange = function() {
    if (this.readyState == 4) {
      if (this.status == 200) {
        tasks = JSON.parse(this.responseText);

        for (i = 0; i < tasks.length; i++) {
            task = tasks[i];
            t = new Task(task.id, 
                         task.name, 
                         null, // stringToDate(task.startTime), 
                         task.estimate/nSecPerMinute);
            t.complete = (task.state == 1);
            t.startTime = stringToDate(task.startTime);
            if (t.complete) {
              done.insertTask(t);
            }
            else {
              if (t.startTime == null) {
                stuff.insertTask(t);
              }
              else {
                scheduled.insertTask(t);
              }
            }
        }
      }
    }
  };
  ajaxGet(ajax, tasksURL());
}

loadTasks();

/*
// set up our test data - eventually these will come from the server
var testTask1 = new Task(1, 'Learn JavaScript', null, 90, false);
var testTask2 = new Task(2, 'Learn Vue', null, 15, false);
var testTask3 = new Task(3, 'Build Something Great', null, null, false);
var testTask4 = new Task(4, 'Watch Football', null, 120, true);
var testTask5 = new Task(5, 'Create Task List', null, 15, true);
var schedule1 = new Task(101, 'EY Audit Review', new Date("January 1, 2000 09:00:00"), 30, false)
var schedule2 = new Task(102, 'Kim 1:1', new Date("January 1, 2000 09:30:00"), 30, false)
var schedule3 = new Task(103, 'Marcus 1:1', new Date("January 1, 2000 10:00:00"), 30, false)

// group my tasks into three arrays for separate display
scheduled.setTitle("Calendar");
scheduled.setId("C");
scheduled.insertTask(schedule1, 'timesort');
scheduled.insertTask(schedule2, 'timesort');
scheduled.insertTask(schedule3, 'timesort');

stuff.setTitle("Stuff");
stuff.setId("S");
stuff.insertTask(testTask1);
stuff.insertTask(testTask2);
stuff.insertTask(testTask3);

done.setTitle("Done");
done.setId("D");
done.insertTask(testTask4);
done.insertTask(testTask5);
*/

function taskListFromID(id) {
	var result = null;
	switch (id) {
		case "C": result = scheduled; break;
		case "S": result = stuff;     break;
		case "D": result = done;      break;
	}
	return result;
}

// this function is called when a task is marked completed
// or "unmarked" completed - it moves the task from list
// to list and if vue works properly it'll be really cool
// note that we get the event the value on the task hasn't
// changed yet so we check for the opposite.
function moveTask(task) {
  if (task == null) { return; }

  // task is done
  if (task.complete) {

    // make sure it is in the done list
    done.insertTask(task, false);

    // if it was in the scheduled or stuff lists remove it
    scheduled.removeTask(task);
    stuff.removeTask(task);


  } else {

    // remove from done list if it was there
    done.removeTask(task);

    // put it into scheduled or stuff by whether it has startTime
    if (task.hasStartTime()) {
      scheduled.insertTask(task, 'timesort');
      stuff.removeTask(task);
    } else {
      stuff.insertTask(task);
      scheduled.removeTask(task);
    }
  }
}

function toggleTask(task) {
 	if (task == null) { return; }
 	task.complete = !task.complete;
 	moveTask(task);

}


// here is a root Vue to hold references to my models
// the data references can be linked to components
new Vue({
  el: '#pim-root',
  data: {
    scheduled: scheduled,
    stuff: stuff,
    done: done
  },
  methods: {
    adjustTask: function(task) { 
      toggleTask(task)
    }
  },
})

</script>
</body>
</html>